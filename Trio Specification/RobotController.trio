class RobotController
	-- RobotController needs to ensure that
	-- 1. the contacts between Operator and Robot can happen only when the Robot is still or is moving very slowly
	-- 1.1. a contact between Operator's head and Robot can happen only when the Robot is still
	-- 1.2. a contact between Operator's arm and Robot can happen only when the speed is slow
	-- 1.3. a contact between Operator's body and Robot can happen only when the speed is slow
	-- 2. the Robot needs to avoid to entrap the Operator between itself and a wall

	-- TODO: missing the exported variables

	temporal domain integer;

	TD items

		predicates
			do({
				PickUpFromBinArea,
				DropToLocalBin,
				GoToWorkingArea,
				PickFromLocalBin,
				DropToTombstone,
				PickFromTombstone,
				MoveToConveyorBelt,
				DropToConveyorBelt,
				GoToBinArea
			});

		variables
			currentAction({
				PickUpFromBinArea,
				DropToLocalBin,
				GoToTombstone,
				PickFromLocalBin,
				DropToTombstone,
				PickFromTombstone,
				MoveToConveyorBelt,
				DropToConveyorBelt,
				GoToBinArea
			}),

			-- None -> Proceed normally with the execution
			-- Emergency -> Stop the robot and wait for the HDICommand to return to None
			-- Continue -> when the robot has placed a piece on the tombstone, it needs to wait for the lavoration to be done and for the operator to signal that the lavoration has terminated.

			HDICommand({
				None,
				Emergency,
				Continue
			});

		modules RobotStatus: RobotStatus,
                        Robot: RobotPositionSensor;

		axioms
			vars t: real;

			-- the actions must be done in the correct order
			correctActionOrder:
			(currentAction == PickUpFromBinArea => Until(currentAction == PickUpFromBinArea, currentAction == DropToLocalBin))
			&&
                        -- After having dropped a piece in the local bin, the robot either takes another or goes to the tombstone
			(currentAction == DropToLocalBin => (Until(currentAction == DropToLocalBin, currentAction == PickUpFromBinArea)
                                       || Until(currentAction == DropToLocalBin, currentAction == GoToTombstone)))
			&&
                        -- After having gone to the tombstone, the robot takes the stored working piece with the end effector
			(currentAction == GoToTombstone => (Until(currentAction == GoToTombstone, currentAction == PickFromLocalBin)))
			&&
			(currentAction == PickFromLocalBin => Until(currentAction == PickFromLocalBin, currentAction == DropToTombstone))
			&&
			(currentAction == DropToTombstone => Until(currentAction == DropToTombstone, currentAction = PickFromTombstone))
			&&
			(currentAction == PickFromTombstone => Until(currentAction == PickFromTombstone, currentAction = MoveToConveyorBelt))
			&&
			(currentAction == MoveToConveyorBelt => Until(currentAction == MoveToConveyorBelt, currentAction == DropToConveyorBelt)
			&&
			(currentAction == DropToConveyorBelt => Until(currentAction == DropToConveyorBelt, currentAction == GoToTombstone) ||
			               Until(currentAction == DropToConveyorBelt, currentAction == GoToBinArea))
			&&
			(currentAction == GoToBinArea => Until(currentAction == GoToBinArea, currentAction == PickUpfromShelf);

			-- the change in currentAction must be preceded by a do request
			correctInit:
			\forall x (Becomes(currentAction == x) \iff do(x));

			-- during emergency mode, the robot needs to be stopped immediately
			emergencyMode: (HDICommand == Emergency) => (RobotStatus.TargetCartSpeed == None) && (RobotStatus.TargetEndEffectorSpeed == None);

			-- do is an instantaneous event (lasts only one time instant)
			instantaneousDo: \forall x (do(x) => Futr(\neg do(x), 1));

			-- precondition of PickUpFromBinArea is that the robot has space in the local bin and is at the bin area
			prePickUpFromBinArea:
				Becomes(currentAction == PickUpFromBinArea) =>
                                    \neg RobotStatus.binFull() && \neg Robot.Arm.holding() &&
                                    \forall x (x \in Robot.Cart.position(x) \implies Grid.binArea(x));

                        duringPickUpFromBinArea:
                            currentAction == PickUpFromBinArea \implies RobotStatus.currentCartSpeed == None;

                        -- the robot must move the arm from the cart
                        -- to the bin area, take the piece from the
                        -- bin area and then move the arm back on top
                        -- of the cart
                        pickUpSequence:
                            Becomes(currentAction == PickUpFromBinArea) \implies \exists t1, t2, t3
                                (0 <= t1 < t2 < t3 < MaxPickUpTime &&
                                Lasts_{ie}(\neg Robot.Arm.holding(), t2) &&
                                Futr(Robot.Arm.endEffector(LBA), t1) &&
                                Futr(Lasts_{ii}(Robot.Arm.holding(), t3), t2) &&
                                Futr(\exists x (Robot.Cart.position(x) && Robot.Arm.endEffector(x)), t3) &&
                                Lasts_{ie}(currentAction == PickUpFromBinArea, t3));

			-- DropToLocalBin requires the robot to be holding a piece and the local bin not to be full
			preDropToLocalBin:
				Becomes(currentAction == DropToLocalBin) => \neg RobotStatus.binFull() && Robot.Arm.holding() && \exists x (Robot.Cart.position(x) && Robot.Arm.endEffector(x));
				
				-- the robot cannot move if the action is DropToLocalBin, and also the endEffector does not have to move
				duringPreDropToLocalBin:
					currentAction == PickUpFromBinArea \implies (RobotStatus.currentCartSpeed == None &&
						RobotStatus.currentEndEffectorSpeed == None)
			
				-- there exists a time t in which the robot switches from holding to not holding
				dropSequence:
					Becomes(currentAction == preDropToLocalBin) \implies \exists t (0 <= t < MaxDropTime && Futr(\neg Robot.Arm.holding(t),t) && Lasts_{ie}(currentAction == DropToLocalBin, t));
					
					

			-- GoToTombstone requires the robot to have the local bin full and not hold any piece
			TODO bloccare end effector sul robot durqante tutta l'azione
			preGoToTombstone:
				Becomes(currentAction == GoToTombstone) => RobotStatus.binFull() && \neg RobotStatus.holding();

			-- precondition for the currentAction to be PickFromLocalBin,DropToTombstone,PickFromTomstone, DropToConveyorBelt is that R is at the WA
			preActionsAtWorkingArea:
				(Becomes(currentAction == PickFromLocalBin) => atWorkingArea) &&
				(Becomes(currentAction == DropToTombstone) => atWorkingArea) &&
				(Becomes(currentAction == PickFromTomstone) => atWorkingArea) &&
				(Becomes(currentAction == DropToConveyorBelt) => atWorkingArea) &&

			-- precondition for the currentAction to be PickFromLocalBin is that the local bin is not empty
				Becomes(currentAction == PickFromLocalBin) => \neg RobotStatus.binEmpty() && \neg RobotStatus.holding();

			-- precondition for the currentAction to be PickFromTombstone is that the WP is finished
			TODO

			-- precondition for the currentAction to be GoToBinArea is that the local bin is empty
			TODO bloccare end effector sul robot durqante tutta l'azione
			preGoToBinArea:
				Becomes(currentAction == GoToBinArea) => RobotStatus.binEmpty() && \neg RobotStatus.holding();

			-- when the bin is full, the robot must go to the tombstone
			binIsFull:
				Becomes(RobotStatus.binFull()) \implies do(GoToTombstone);
				
			TODO bloccare end effector sul robot durqante tutta l'azione in go to conveyor belt
end RobotController.
